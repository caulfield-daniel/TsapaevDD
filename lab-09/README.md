# **Тема 09: Динамическое программирование**

**Цель работы:** Изучить метод динамического программирования (ДП) как мощный инструмент для решения сложных задач путём их разбиения на перекрывающиеся подзадачи. Освоить два основных подхода к реализации ДП: нисходящий (с мемоизацией) и восходящий (с заполнением таблицы). Получить практические навыки выявления оптимальной подструктуры задач, построения таблиц ДП и анализа временной и пространственной сложности алгоритмов.

**Теория (кратко):**

* **Динамическое программирование (ДП):** Метод решения задач, в которых оптимальное решение всей задачи зависит от оптимальных решений её **перекрывающихся подзадач**.
* **Ключевые принципы:**
  * **Оптимальная подструктура:** Оптимальное решение задачи может быть построено из оптимальных решений её подзадач.
  * **Перекрывающиеся подзадачи:** Подзадачи, решения которых используются многократно, а не один раз.
* **Подходы к реализации:**
  * **Нисходящее ДП (Top-Down, с мемоизацией):** Рекурсивное решение с сохранением (кэшированием) результатов решения подзадач для повторных вычислений.
  * **Восходящее ДП (Bottom-Up, табличное):** Итеративное решение, при котором подзадачи решаются от простейших к сложным, а их результаты заносятся в таблицу (массив).
* **Области применения:** Задачи оптимизации, подсчёта количества способов, нахождения наиболее вероятной последовательности.
* **Классические задачи:**
  * **Числа Фибоначчи:** Классический пример перекрывающихся подзадач.
  * **Задача о рюкзаке (0-1 Knapsack):** Выбор предметов с максимальной суммарной стоимостью без дробления.
  * **Наибольшая общая подпоследовательность (LCS):** Поиск самой длинной последовательности символов, которая является подпоследовательностью двух строк.
  * **Расстояние Левенштейна (Редакционное расстояние):** Минимальное количество операций вставки, удаления и замены символа, необходимых для превращения одной строки в другую.

**Практика (подробно):**

**Задание:**

1. Реализовать классические алгоритмы динамического программирования.
2. Реализовать оба подхода (нисходящий и восходящий) для решения задач.
3. Провести сравнительный анализ эффективности двух подходов.
4. Проанализировать временную и пространственную сложность алгоритмов.
5. Решить практические задачи с применением ДП.

**Шаги выполнения:**

1. **Создание проекта:** Создать файлы `dynamic_programming.py`, `comparison.py`.
2. **Реализация алгоритмов ДП (в `dynamic_programming.py`):**
    * **Числа Фибоначчи:**
        * Реализовать наивную рекурсию, рекурсию с мемоизацией и итеративное табличное решение.
    * **Задача о рюкзаке (0-1 Knapsack):**
        * Реализовать восходящий подход с заполнением 2D-таблицы `dp[i][w]`.
    * **Наибольшая общая подпоследовательность (LCS):**
        * Реализовать восходящий подход с заполнением 2D-таблицы `dp[i][j]`.
    * **Расстояние Левенштейна:**
        * Реализовать восходящий подход с заполнением 2D-таблицы `dp[i][j]`.
    * **Для каждого алгоритма указать его временную и пространственную сложность.**
3. **Сравнительный анализ (в `comparison.py`):**
    * Сравнить время работы и потребление памяти нисходящего (с мемоизацией) и восходящего подхода для вычисления чисел Фибоначчи для больших `n`.
    * Сравнить результат жадного алгоритма для непрерывного рюкзака с результатом ДП для задачи о рюкзаке 0-1.
4. **Восстановление решения:**
    * Для задачи LCS или рюкзака реализовать функцию не только для нахождения значения (длины/стоимости), но и для восстановления самой подпоследовательности/набора предметов.
5. **Решение задач:**
    * Решить задачу "Размен монет" (минимальное количество монет для суммы) с помощью ДП.
    * Решить задачу "Наибольшая возрастающая подпоследовательность (LIS)".
6. **Экспериментальное исследование:**
    * Исследовать масштабируемость алгоритмов ДП (например, рюкзака) при увеличении размера входных данных.
    * **ВАЖНО: Все замеры проводить на одной вычислительной машине.**
7. **Визуализация:**
    * Визуализировать процесс заполнения таблицы ДП для небольших входных данных (например, выводить таблицу на каждом шаге или в конце).
    * Построить графики зависимости времени выполнения от размера задачи.
8. **Анализ результатов:**
    * Сравнить эффективность разных подходов ДП.
    * Проанализировать, как увеличение параметров задачи влияет на время и память.
9. **Оформление отчета:** Результаты оформить в файле `README.md`. Код должен соответствовать PEP8.
10. **Контроль версий:** Стратегия ветвления – GitHub Flow.

**Контрольные вопросы:**

1. Какие два основных свойства задачи указывают на то, что для ее решения можно применить динамическое программирование?
2. В чем разница между нисходящим (top-down) и восходящим (bottom-up) подходами в динамическом программировании?
3. Как задача о рюкзаке 0-1 демонстрирует свойство оптимальной подструктуры?
4. Опишите, как строится и заполняется таблица для решения задачи о наибольшей общей подпоследовательности (LCS).
5. Как с помощью динамического программирования можно уменьшить сложность вычисления чисел Фибоначчи с экспоненциальной до линейной или даже до O(log n)?

**Критерии оценки:**

* **Оценка «3» (удовлетворительно):**
  * Реализованы 2 алгоритма ДП (например, Фибоначчи и рюкзак) одним подходом.
  * В коде присутствуют комментарии с оценкой сложности.
  * Проведены базовые замеры производительности.

* **Оценка «4» (хорошо):**
  * Выполнены все критерии на «3».
  * Реализованы 3 алгоритма ДП (добавлена LCS или Левенштейн).
  * Реализованы оба подхода (мемоизация и табличный) для одной из задач.
  * Код хорошо отформатирован и полностью прокомментирован.
  * Проведено сравнение двух подходов ДП.
  * Решены 2 практические задачи.

* **Оценка «5» (отлично):**
  * Выполнены все критерии на «4».
  * Приведены характеристики ПК для тестирования.
  * Реализовано восстановление решения для одной из задач (LCS/рюкзак).
  * Проведен полный сравнительный анализ подходов ДП по времени и памяти.
  * Проанализирована пространственная оптимизация алгоритмов (например, использование одномерного массива для рюкзака).
  * Решены 3+ практические задачи с анализом выбора метода.

## **Рекомендованная литература**

1. Юрий Петров: "Программирование на Python" — онлайн-курс и учебные материалы.
    ○ Ссылка для изучения: <https://www.yuripetrov.ru/edu/python/index.html>
2. Кормен, Т., Лейзерсон, Ч., Ривест, Р., Штайн, К. Алгоритмы: построение и анализ, 3-е издание. — М.: Вильямс, 2022. — 1328 с.
    ○ (Оригинальное название: Cormen, T.H., Leiserson, C.E., Rivest, R.L., Stein, C. Introduction to Algorithms, 3rd Edition)
3. Skiena, Steven S. The Algorithm Design Manual, 3rd ed.
