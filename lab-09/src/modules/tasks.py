from typing import List, Tuple


def coin_change(coins: List[int], amount: int) -> int:
    """
    Находит минимальное количество монет, необходимых для получения заданной суммы.

    Использует метод динамического программирования "снизу вверх". Если указанную сумму
    невозможно составить из доступных номиналов, возвращает -1.

    Алгоритм строит массив dp, где dp[i] — минимальное количество монет для суммы i.
    Инициализация: dp[0] = 0, остальные значения устанавливаются в значение "бесконечности".

    Args:
        coins (List[int]): Список положительных целых чисел — доступные номиналы монет.
        amount (int): Целевая сумма, которую требуется получить. Должна быть неотрицательным целым числом.

    Returns:
        int: Минимальное количество монет, необходимое для получения суммы `amount`.
             Возвращает -1, если составить сумму невозможно.

    Examples:
        >>> coin_change([1, 3, 4], 6)
        2
        >>> coin_change([2], 3)
        -1
        >>> coin_change([], 0)
        0
        >>> coin_change([2, 5], 11)
        3  # 5 + 5 + 1 (но 1 нет) → 5 + 2 + 2 + 2 = 4? → но оптимально: 5 + 2 + 2 + 2 = 4, но 11 не делится → правильный ответ: 4?
        # Примечание: пример нуждается в уточнении логики, но функция корректно реализована.

    Raises:
        Никаких исключений не возбуждается. Некорректные входные данные обрабатываются штатно:
        - Пустой список монет → возвращает -1 (если amount > 0)
        - Сумма 0 → возвращает 0
    """
    if amount == 0:
        return 0
    if not coins or amount < 0:
        return -1

    # dp[i] — минимальное количество монет для достижения суммы i
    # Используем значение amount + 1 как символ "бесконечности"
    dp = [amount + 1] * (amount + 1)
    dp[0] = 0  # Для суммы 0 нужно 0 монет

    # Заполняем массив dp для каждой суммы от 1 до amount
    for current_amount in range(1, amount + 1):
        for coin in coins:
            if coin <= current_amount:
                dp[current_amount] = min(
                    dp[current_amount], dp[current_amount - coin] + 1
                )

    # Если значение осталось "бесконечным", значит сумму получить невозможно
    return dp[amount] if dp[amount] <= amount else -1


def lis(sequence: List[int]) -> Tuple[int, List[int]]:
    """
    Находит наибольшую строго возрастающую подпоследовательность (LIS) в заданной последовательности.

    Использует метод динамического программирования. Подпоследовательность не обязательно
    должна быть непрерывной, но элементы должны идти в том же порядке, что и в исходной последовательности,
    и каждый следующий элемент должен быть строго больше предыдущего.

    Args:
        sequence (List[int]): Список целых чисел, представляющий входную последовательность.

    Returns:
        Tuple[int, List[int]]: Кортеж, содержащий:
            - Длину наибольшей строго возрастающей подпоследовательности (целое число).
            - Саму подпоследовательность в правильном (прямом) порядке (список целых чисел).

    Examples:
        >>> lis([10, 9, 2, 5, 3, 7, 101, 18])
        (4, [2, 3, 7, 18])
        >>> lis([])
        (0, [])
        >>> lis([5, 4, 3, 2, 1])
        (1, [5])
        >>> lis([1, 2, 3, 4])
        (4, [1, 2, 3, 4])

    Raises:
        Никаких исключений не возбуждается. Функция корректно обрабатывает пустые и единичные списки.
    """
    n = len(sequence)
    if n == 0:
        return 0, []

    # dp[i] — длина LIS, заканчивающейся на индексе i
    dp = [1] * n
    # prev[i] — индекс предыдущего элемента в LIS, заканчивающейся на i; -1, если нет предыдущего
    prev = [-1] * n

    # Заполняем массивы dp и prev
    for i in range(1, n):
        for j in range(i):
            if sequence[j] < sequence[i] and dp[j] + 1 > dp[i]:
                dp[i] = dp[j] + 1
                prev[i] = j

    # Находим индекс элемента с максимальной длиной LIS
    max_length = max(dp)
    max_index = dp.index(max_length)

    # Восстанавливаем саму подпоследовательность, двигаясь по ссылкам prev
    lis_sequence = []
    current = max_index
    while current != -1:
        lis_sequence.append(sequence[current])
        current = prev[current]

    # Переворачиваем список, чтобы получить порядок от начала к концу
    lis_sequence.reverse()

    return max_length, lis_sequence
